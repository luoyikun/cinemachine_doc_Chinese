{
  "Common": {
    "InThisArticle": "本文内容",
    "Section": "章节",
    "Description": "描述"
  },
  "CinemachinePackage": {
    "title": "Cinemachine 组件",
    "title.comment": "Cinemachine package's title",
    "descriptionParagraphOne": "Cinemachine 是一套用于控制 Unity 摄像机的模块组件。Cinemachine 解决了跟踪目标跟踪、组合、协调、和切换效果而产生的复杂数学和逻辑问题。它旨在显著减少开发过程中耗费时间的手动操作和脚本修改次数。",
    "descriptionParagraphOne.comment": "Cinemachine package's first paragraph description",
    "descriptionParagraphTwo": "这些模块的过程性特点使得 Cinemachine 强大而宽容。当您进行调整时 - 例如，更改动画、车辆速度、地形或场景中的其他 GameObjects - Cinemachine 会动态调整其行为以获得最佳镜头效果。例如，只要一个角色向左转而不是向右转，就无需重新编写摄像机脚本。",
    "descriptionParagraphTwo.comment": "Cinemachine package's second paragraph description",
    "descriptionParagraphThree": "Cinemachine 可以实时工作在各种类型的游戏中，包括第一人称射击、第三人称、2D、横向卷轴、俯视视角和实时战略游戏。它支持您场景中需要的任意数量的镜头。其模块化系统使您能够组合复杂的行为。",
    "descriptionParagraphThree.comment": "Cinemachine package's third paragraph description",
    "descriptionParagraphFour": "Cinemachine 与其他 Unity 工具兼容良好，作为 Timeline、动画和后期处理资产的强大补充。您可以创建自己的扩展或将其与自定义摄像机脚本集成。",
    "descriptionParagraphFour.comment": "Cinemachine package's fourth paragraph description"
  },
  "InstallationAndUpgrade": {
    "title": "安装和升级",
    "title.comment": "Installation and upgrade section title",
    "installationParagraphOne": "Cinemachine是一个免费的包，可用于任何项目。您可以像安装其他包一样安装Cinemachine。",
    "installationParagraph.comment": "Installation paragraph",
    "installationParagraphTwo": "安装Cinemachine后，将出现一个新的GameObject > Cinemachine菜单。您也可以在层次视图中右键单击时访问此菜单。",
    "installationParagraphTwo.comment": "Installation paragraph two",
    "requirementsTitle": "系统要求",
    "requirementsTitle.comment": "Requirements title",
    "requirementsParagraphOne": "Cinemachine几乎没有外部依赖。只需安装它并开始使用。如果您还在使用通过HDRP或URP卷进行后期处理，则提供了适配器模块 - 受#ifdef指令保护，如果检测到依赖项的存在，则会自动定义。",
    "requirementsParagraphOne.comment": "Requirements paragraph one",
    "requirementsParagraphTwo": "对于其他包，如Timeline和UGUI，也有类似的#ifdef保护行为。",
    "requirementsParagraphTwo.comment": "Requirements paragraph two",
    "requirementsParagraphThree": "此版本的Cinemachine受以下Unity编辑器版本的支持：",
    "requirementsParagraphThree.comment": "Requirements paragraph three",
    "requirementVersion": "2022.2.16f1及更高版本",
    "requirementVersion.comment": "Requirement version",
    "upgradingTitle": "从以前的Cinemachine版本升级",
    "upgradingTitle.comment": "Upgrading title",
    "upgradingParagraphOne": "Cinemachine 3.0是从CM 2.X到主要版本更改，API和数据格式已经发生了重大变化。针对CM 2.X API编写的脚本很可能无法在3.X上运行，除非进行手动干预。此外，项目中的CM摄像机实例本身也需要升级。",
    "upgradingParagraphOne.comment": "Upgrading paragraph one",
    "upgradingParagraphTwo": "虽然有可能从CM 2.X升级现有项目，但您应该仔细考虑是否愿意付出努力。在许多情况下，最好还是继续使用CM 2.X，在CM 3.X并行支持一段时间后继续支持。如果您选择升级项目，请参阅升级指南。",
    "upgradingParagraphTwo.comment": "Upgrading paragraph two",
    "upgradingParagraphThree": "Cinemachine 3.0以废弃形式继续支持已被新版本取代的过时CM2类。这是为了帮助您顺利过渡到新的API。然而，强烈建议您尽快将项目升级以使用新的API。废弃的类将在将来的版本中被移除。为了减少您的交付内容中的代码膨胀，您可以通过在项目的脚本定义符号中定义CINEMACHINE_NO_CM2_SUPPORT来立即删除废弃的类支持。",
    "upgradingParagraphThree.comment": "Upgrading paragraph three",
    "upgradingFromOldTitle": "从旧版Asset Store的Cinemachine升级",
    "upgradingFromOldTitle.comment": "Upgrading from old title",
    "upgradingFromOldParagraphOne": "如果您已经安装了Unity Asset Store中的一个非常旧版本的Cinemachine，那么您应该升级到Cinemachine Package。在这种情况下，建议您升级到Cinemachine 2.X，这在大多数情况下是完全自动的。",
    "upgradingFromOldParagraphOne.comment": "Upgrading from old paragraph one",
    "upgradingFromOldParagraphTwo": "要升级到Cinemachine Package：",
    "upgradingFromOldParagraphTwo.comment": "Upgrading from old paragraph two",
    "upgradingFromOldSteps": [
      "在Unity编辑器中，2019.4或更高版本，打开您的项目。",
      "保存您正在工作的当前场景。",
      "创建一个新的空场景。",
      "在项目窗口中，删除Cinemachine资产和您可能安装的任何Cinemachine后期处理适配器资产。",
      "安装Cinemachine 2.X包。"
    ],
    "upgradingFromOldSteps.comment": "Upgrading from old Asset stores steps"
  },

  "UpgradingProjectFromCinemachine2X": {
    "UpgradingProjectFromCinemachine2XTitle": "从Cinemachine 2.X升级项目",
    "UpgradingProjectFromCinemachine2XParagraphOne": "Cinemachine 3.0是从CM 2.X到主要版本更改，API和数据格式已经发生了重大变化。针对CM 2.X API编写的脚本很可能无法在3.X上运行，除非进行手动干预。此外，项目中的CM对象数据本身也需要升级。",
    "UpgradingProjectFromCinemachine2XParagraphTwo": "虽然有可能从CM 2.X升级现有项目，但您应该仔细考虑是否愿意付出努力。在许多情况下，最好还是继续使用CM 2.X，在CM 3.X并行支持一段时间后继续支持。如果您选择考虑升级项目，本指南将为您提供一些指示，使过程更加顺畅。",

    "UpgradingYourProjectStepByStepTitle": "逐步升级您的项目",
    "UpgradingYourProjectStepByStepParagraphOne": "以下是从CM 2.X升级现有项目的步骤：",
    "UpgradingYourProjectStepByStepList": [
      "备份您的项目。不要跳过此步骤。",
      "使用包管理器将您的项目升级到CM3。如果您有使用Cinemachine API的自定义脚本，它们可能会中断。通过执行以下操作使它们重新编译：",
      "1 更新使用Cinemachine声明。命名空间已更改为Unity.Cinemachine。",
      "2 更新对重命名组件的任何引用。",
      "3 更新损坏的CM字段名称。大多数情况下，这只意味着删除m_前缀。在其他情况下，可能需要做更多工作，但通过查看每种情况中的代码，应该可以清楚地了解要采取的适当操作。",
      "4 此时，您的项目应该基本上像以前一样运行，使用废弃的类。",
      "用于替换CinemachineVirtualCamera和CinemachineFreeLook的新CinemachineCamera类继承自CinemachineVirtualCameraBase。在可能的情况下，请替换您的脚本引用以使用此基类而不是派生类型。如果这样做，CM升级工具将能够保留现有对象引用，因为旧类和新类都继承自同一基类。",
      "通过运行Cinemachine Upgrader来升级项目数据。您可以从任何CM VirtualCamera或FreeLook检查器中启动Cinemachine Upgrader工具。",
      "因为CM组件类型已更改，您将不得不手动查看您的脚本，并更新任何特定引用以适应新类型。控制台日志是您的好帮手：\"废弃\"警告将指出需要注意的地方。",
      "数据升级后，对象引用可能会中断。如果需要，您需要检查并修复它们。",
      "如果您使用层来将摄像机过滤到单独的分屏大脑中，那么该过滤将停止工作，直到您升级为CinemachineCameras并将过滤切换到通道为止。"
    ],
    "UpgradingYourProjectStepByStepParagraphTwo": "注意：如果在任何阶段出现此类错误，请重新启动Unity：",

    "WhatHasChangedInTheAPITitle": "API中的变化",
    "WhatHasChangedInTheAPIParagraphOne": "一些组件被新组件替换，其他组件被重命名。字段名称已更改。命名空间已更改。对于这些问题中的大多数，您将在控制台中看到错误或弃用警告，这将指示您需要关注的代码区域。",
    "WhatHasChangedInTheAPIParagraphTwo": "需要注意的一点是：用于替换CinemachineVirtualCamera和CinemachineFreeLook的新CinemachineCamera类继承自CinemachineVirtualCameraBase。如果可能的话，您可以替换您的脚本引用以尽可能使用此基类，那么在升级数据时，现有对象引用将被保留，因为旧类和新类都继承自同一基类。",

    "NewNamespacesTitle": "新命名空间",
    "NewNamespacesParagraphOne": "命名空间已更改，以更符合Unity标准。",
    "NewNamespacesList": [
      "Cinemachine现在是Unity.Cinemachine",
      "Cinemachine.Editor现在是Unity.Cinemachine.Editor",
      "Cinemachine.Utility已被合并到Unity.Cinemachine。"
    ],

    "NewComponentsWithClearerNamesTitle": "具有更清晰名称的新组件",
    "NewComponentsWithClearerNamesParagraphOne": "旧组件已被新组件替换。这些不是重命名，而是新的组件类型。旧组件仍然存在，但已弃用。如果您的脚本引用了其中任何组件，则在完成数据升级后，它们将需要更新。",
    "NewComponentsWithClearerNamesList": [
      "CinemachineVirtualCamera被CinemachineCamera替换。",
      "CinemachineFreeLook被CinemachineCamera替换。",
      "CinemachinePath和CinemachineSmoothPath被Unity的新原生样条实现提供的Spline Container替换。",
      "CinemachineDollyCart被CinemachineSplineCart替换。",
      "CinemachineTransposer被CinemachineFollow替换。",
      "CinemachineOrbitalTransposer被CinemachineOrbitalFollow替换",
      "CinemachineFramingTransposer被CinemachinePositionComposer替换。",
      "CinemachineComposer被CinemachineRotationComposer替换。",
      "CinemachinePOV被CinemachinePanTilt替换。",
      "CinemachineTrackedDolly被CinemachineSplineDolly替换。",
      "CinemachineGroupComposer被与CinemachineRotationComposer配合使用的CinemachineGroupFraming扩展替换。",
      "CinemachineCollider被CinemachineDeoccluder替换",
      "CinemachineConfiner被CinemachineConfiner2D和CinemachineConfiner3D替换",
      "Cinemachine3rdPersonFollow被CinemachineThirdPersonFollow替换。",
      "CinemachineSameAsFollowTarget被CinemachineRotateWithFollowTarget替换。"
    ],

    "RenamedComponentsTitle": "重命名组件",
    "RenamedComponentsList": [
      "Cinemachine3rdPersonAim已更名为CinemachineThirdPersonAim。",
      "CinemachineBlendListCamera已更名为Cinemachine Sequencer Camera。"
    ],

    "RenamedFieldsTitle": "重命名字段",
    "RenamedFieldsParagraphOne": "从旧的\"m_FieldName\"约定已更改为遵循Unity的最新命名约定。因此，在所有地方都已删除了\"m_\"前缀。如果您的脚本由于此原因而无法编译，则首要解决方法是从您的脚本引用的字段名称中删除\"m_\"。大多数情况下，这将足够。偶尔，某些字段名称更改更为重大。找到适当的替换应该相当容易。",
    "RenamedFieldsParagraphTwo": "SimpleFollowWithWorldUp绑定模式已重命名为LazyFollow。",

    "CleanerObjectStructureNoHiddenGameObjectsTitle": "更干净的对象结构，没有隐藏的GameObject",
    "CleanerObjectStructureNoHiddenGameObjectsParagraphOne": "Cinemachine 2.x在vcam的隐藏GameObject子级上实现了CM管道，命名为\"cm\"。这在CineMachine 3.0中已被移除，CM管道组件（如OrbitalFollow或RotationComposer）现在直接作为组件实现在CinemachineCamera GameObject上。您可以像访问任何其他组件一样访问它们：不再需要GetCinemcachineComponent()，只需使用GetComponent()。",
    "CleanerObjectStructureNoHiddenGameObjectsParagraphTwo": "您现在将在层次结构中看到您遗留的CM vcam的cm子对象，因为CM3已将它们取消隐藏。这并不意味着您可以随意更改这些对象 - 它们之前被隐藏是有原因的。我们建议您通过将父对象升级为其CM3等效对象来摆脱它们。",

    "NewInputHandlingTitle": "新输入处理",
    "NewInputHandlingParagraphOne": "用户输入已与Cinemachine组件解耦：它们不再直接读取用户输入，而是期望由外部组件驱动。提供了CinemachineInputAxisController来执行此作业，但您也可以选择通过继承InputAxisControllerBase来实现自己的输入控制器。",

    "NewEventsArchitectureTitle": "新事件架构",
    "NewEventsArchitectureParagraphOne": "尽管CM2.X在CinemachineVirtualCamera和CinemachineBrain中具有事件，但CM3仅通过CinemachineCore触发全局事件。脚本可以向这些事件添加监听器，并根据它们采取行动。监听器将接收到所有摄像机和所有Brains的事件。",
    "NewEventsArchitectureParagraphTwo": "现在支持特定于摄像机和Brain的事件，通过两个新行为实现：Cinemachine Brain Events和Cinemachine Camera Events。这些监视全局事件，并触发与其附加的对象相关的更专业的事件。",

    "NewSplineImplementationTitle": "新样条实现",
    "NewSplineImplementationParagraphOne": "Cinemachine的路径现在使用Unity的原生Splines实现，提供了等效的功能。Cinemachine Upgrader将自动将您的CM路径转换为Splines。CM路径实现仍然存在，但现已弃用。",

    "DecoupledFromUnityLayersTitle": "与Unity层解耦",
    "DecoupledFromUnityLayersParagraphOne": "在CM2中，CinemachineBrain仅会处理分配给与相关摄像机的culling mask中包含的层的CinemachineCameras。这种机制在诸如分屏之类的情况下非常有用，以使特定的CinemachineCameras分配给特定的Brains。在CM3中，这已被Cinemachine Channels取代。这些是仅Cinemachine使用的专用层，因此不会不必要地浪费Unity层。CinemachineCameras被分配到一个Cinemachine Channel，并且CinemachineBrain有一个通道掩码。通常情况下，使用\"Default\"通道，并且只需要在需要通道分离的特定情况下更改。",

    "LensModeOverrideTitle": "镜头模式覆盖",
    "LensModeOverrideParagraphOne": "如果您的项目正在使用镜头模式覆盖的虚拟摄像机（例如，在物理和透视和正交摄像机之间切换），那么在您启用模式覆盖并在CinemachineBrain中分配默认镜头模式之前，这将停止工作。",

    "UpgradingTheProjectDataTitle": "升级项目数据",
    "UpgradingTheProjectDataParagraphOne": "一旦脚本使用新的API，您就可以升级项目数据，将传统的CM对象转换为其CM3对应项。Cinemachine附带了一个数据升级工具来促进此操作。这不是一个简单的操作，因为除了场景中的vcam对象之外，还需要升级可能正在引用它们的预制件和动画资产。",
    "UpgradingTheProjectDataParagraphTwo": "您可以从任何CM VirtualCamera或FreeLook检查器中启动Cinemachine Upgrader升级工具：",

    "UpgradingASingleObjectTitle": "升级单个对象 Object",
    "UpgradingASingleObjectParagraphOne": "如果您只想升级当前正在检查的Cinemachine对象，则只要它不是预制件实例，您就可以这样做。在这种情况下，它将仅升级已检查的对象，将它们替换为CM3等效项。支持撤消，因此您可以尝试一下，然后改变主意。",
    "UpgradingASingleObjectParagraphTwo": "请注意，此对象的任何脚本引用都将丢失（因为类将更改），任何写入到此相机内部字段的动画轨道也将丢失（因为类和字段名称已更改）。引用此对象的时间轴将失去其绑定。如果您有脚本引用或动画轨道或如果此摄像机是预制件或预制件实例的一部分，则需要使用\"升级整个项目\"选项，该选项将扫描项目中的引用并进行适当的更新。",

    "UpgradingASingleSceneTitle": "升级单个场景 Scene",
    "UpgradingASingleSceneParagraphOne": "您还可以选择更新当前场景中的所有CM对象。同样，这不会更新场景外的任何资产，因此对于除最简单的场景之外的任何场景都不适用。此操作也支持撤消。",

    "UpgradingTheWholeProjectTitle": "升级整个项目",
    "UpgradingTheWholeProjectParagraphOne": "“升级整个项目”选项将升级所有场景和所有预制件中的所有对象。有逻辑来处理动画轨道、脚本引用和预制件实例。这是一个重要的操作，项目中的每个场景和预制件都将被打开和保存多次。不支持撤消，因此请务必先进行完整备份。"
  },

  "GetStarted": {
    "title": "开始使用Cinemachine",
    "paragraphOne": "获取必要的信息，了解Cinemachine的工作原理，并按照说明设置最小功能层，以在项目中开始使用Cinemachine。",
    "sections": [
      "Cinemachine核心概念",
      "设置基本的Cinemachine环境",
      "设置多个Cinemachine摄像机和过渡",
      "向Cinemachine摄像机添加程序化行为",
      "在Cinemachine摄像机中设置时间线",
      "使用方便的工具和快捷方式"
    ],
    "descriptions": [
      "了解Cinemachine的基本要素和核心功能。",
      "设置Unity项目，以包含最低所需元素，以建立功能性的Cinemachine环境。",
      "设置具有多个Cinemachine摄像机的Cinemachine环境，并管理它们之间的过渡。",
      "向Cinemachine摄像机添加程序化行为，使其跟随目标、抖动等。",
      "在Cinemachine环境中设置时间线，编排Cinemachine摄像机，生成可预测的镜头序列。",
      "使用界面工具和快捷方式，并针对您的需求定位正确的Cinemachine元素进行设置，以简化配置体验。"
    ]
  },
  "TrackingScenario3D": {
    "title": "3D跟踪场景",
    "paragraphOne": "利用Cinemachine跟随和观察您的3D游戏中的活动角色",
    "list": [
      "跟踪和框定角色",
      "跟踪和框定群组",
      "创建自由视角相机",
      "创建第三人称相机"
    ]
  },
  "TopDownGamesAnd2DPage": {
    "title": "2D和俯视视角游戏",
    "paragraphOne": "使用和配置Cinemachine以满足2D游戏和俯视视角游戏的特定要求。",
    "list": ["Cinemachine和2D图像", "Cinemachine和俯视视角游戏"]
  },
  "ConstrainCameraToPath": {
    "title": "使相机沿路径移动",
    "paragraphOne": "利用样条线约束相机沿着预定义且可自定义的路径移动。",
    "paragraphTwo": "样条线路径由场景中的样条线形成。使用样条线指定固定路线来定位或动画CinemachineCamera。使用样条线推车行为让您的CinemachineCamera沿着样条线路径移动。",
    "paragraphThree": "创建带有推车路径的Cinemachine相机：",
    "pargraphThreeList": [
      "在Unity菜单中，选择GameObject > Cinemachine > Dolly Camera with Spline。层次结构中将出现一个新的Cinemachine相机和样条线。",
      "在层次结构窗口中，选择新的推车样条线GameObject。",
      "在检视器或场景视图中添加和调整路径点。"
    ],
    "paragraphFour": "任何Unity样条线都可用作Cinemachine中的路径。只需将其拖放到Spline Dolly Spline属性字段中，即可使CinemachineCamera限制在样条线上。",
    "paragraphFive": "默认情况下，Unity样条线不包含旋转数据。相机的旋转将根据任意点的样条线切线和世界Up向量进行推断。要在切线周围添加旋转，您可以使用Cinemachine样条线滚动行为。这允许您为样条线上的任何点指定滚动值。滚动值用于使相机绕该点的样条线切线旋转，从而更好地控制相机的最终旋转。",
    "paragraphSix": "如果向样条线添加了Cinemachine样条线滚动行为，则所有使用该样条线的相机和推车都会看到它。或者，您可以将Cinemachine样条线滚动行为添加到Cinemachine相机本身，这样滚动值将仅适用于它。"
  },

  "ApplyNoiseSimulationPage": {
    "title": "应用噪声模拟相机抖动",
    "paragraphOne": "要将噪声行为应用于Cinemachine相机：",
    "paragraphOneList": [
      "在层次结构窗口中，选择您的Cinemachine相机。",
      "在检视器窗口中，在Cinemachine相机组件中，选择Noise，然后选择Basic Multi Channel Perlin。这将向Cinemachine相机添加一个噪声行为。",
      "在Basic Multi Channel Perlin组件下的Noise Profile中，选择现有的噪声配置文件资源或创建自己的配置文件。",
      "使用Amplitude Gain和Frequency Gain来微调噪声。"
    ],
    "paragraphTwo": "噪声通常用于诸如手持相机效果等需要连续噪声的情况。对于突然的抖动（例如响应爆炸等事件），我们建议使用Impulse而不是Noise。"
  },
  "ManageGroupedCameras": {
    "title": "管理分组相机",
    "paragraphOne": "管理相机监督多个Cinemachine相机，但在Cinemachine Brain和时间轴的视角下，它们作为单个Cinemachine相机。",
    "paragraphTwo": "Cinemachine包括以下管理相机：",
    "paragraphTwoList": [
      "序列相机：执行其子Cinemachine相机的混合或切换序列。",
      "清晰镜头相机：选择最佳视角的子Cinemachine相机。",
      "状态驱动相机：根据动画状态的变化选择子Cinemachine相机。",
      "混合相机：通过使用最多八个子Cinemachine相机的加权平均值创建连续混合。"
    ],
    "paragraphThree": "由于管理相机的行为类似于普通的Cinemachine相机，因此您可以将它们嵌套。换句话说，您可以创建任意复杂的相机架构，将常规Cinemachine相机和管理相机结合在一起。",
    "subtitleOne": "制作您自己的自定义管理相机",
    "paragraphFour": "您还可以制作自己的管理相机，根据您提供的任意算法选择当前活动的子相机。例如，如果您正在制作一个2D平台游戏，并希望一个相机架构根据角色是向右移动还是向左移动，或者跳跃还是下落而对自身进行不同的定位，那么自定义CameraManager类可能是一个不错的选择。",
    "paragraphFive": "为此，请创建一个新类，继承CinemachineCameraManagerBase。该基类实现了一组Cinemachine相机子级和混合器。",
    "paragraphSix": "接下来，实现抽象的ChooseCurrentCamera方法。当管理器处于活动状态时，每帧都会调用此方法，并且应返回本帧应该处于活动状态的子相机。您的自定义类可以以任何方式做出此决定。在示例中，它将查看玩家状态以确定面对方向和跳跃/下落状态，并选择适当的子相机。",
    "paragraphSeven": "如果新的期望相机与上一帧不同，则CinemachineCameraManagerBase将根据您在其DefaultBlend和CustomBlends字段中设置的内容启动混合。",
    "paragraphEight": "添加了您喜欢的每个玩家状态的子相机，并将它们连接到您的管理器实例后，您将拥有一个根据玩家状态调整自身的Cinemachine架构。该架构本身对于系统的其他部分来说看起来就像一个普通的Cinemachine相机，因此可以在Cinemachine相机可以的任何地方使用 - 包括嵌套在其他架构中。",
    "paragraphNine": "请注意，Cinemachine附带了状态驱动相机，它实现了此功能，前提是相关的玩家状态已编码在动画控制器状态机中。如果状态不是从动画控制器中读取，则需要自己实现管理器。",
    "subtitleTwo": "托管的相机需要成为管理器的GameObject子级",
    "paragraphTen": "这主要是为了防止嵌套管理器可能出现的问题，导致递归循环。强制托管相机成为子级使递归变得不可能。"
  },
  "AvoidCollisionsAndEvaluateShots": {
    "title": "避免碰撞和评估镜头",
    "paragraphOne": "当角色和物体在复杂的场景中移动时，场景中的障碍物有时会阻挡相机和其目标之间的视线。同样，您可能需要将相机移动到场景中另一个游戏对象已经占据的位置。Cinemachine提供了处理这些情况的扩展：",
    "paragraphOneList": [
      "Cinemachine 解碰撞器 (Decollider)",
      "Cinemachine 解遮挡器 (Deoccluder)",
      "Cinemachine 限制器 3D (Confiner 3D)",
      "Cinemachine 限制器 2D (Confiner 2D)"
    ]
  },
  "CinemachineEvents": {
    "title": "Cinemachine 事件",
    "paragraphOne": "每当相机被激活或停用时，以及在开始和结束混合时，Cinemachine都会生成事件。此外，当进行相机切换时（即在没有混合的情况下更改活动的Cinemachine相机），也会生成事件。",
    "paragraphTwo": "当Cinemachine发送事件时，它会通过CinemachineCore全局发送。脚本可以添加监听器来监听这些事件并根据它们采取行动。监听器将接收所有相机的事件。",
    "paragraphThree": "事件在管理混合的每个上下文中生成。这包括处理最高级别混合的CinemachineBrain，也适用于管理其子相机之间混合的Cinemachine管理相机。",
    "paragraphFour": "有时需要仅为特定相机发送事件，以便脚本可以根据该特定相机的活动收到通知，而无需提供代码来过滤事件。Cinemachine提供以下行为来执行此过滤逻辑。",
    "paragraphFourList": [
      "通过向特定CinemachineCamera或ManagerCamera添加Cinemachine相机事件行为，可以捕捉与激活或停用该相机相关的事件。",
      "通过向ManagerCamera添加Cinemachine相机管理器事件行为，可以捕捉由其生成的事件。",
      "通过向特定CinemachineBrain添加Cinemachine脑事件行为，可以捕捉由其生成的事件。"
    ]
  },
  "CinemachineImpulse": {
    "title": "Cinemachine 脉冲（Impulse）",
    "paragraphOne": "Cinemachine 脉冲会根据游戏事件生成和管理相机震动。例如，当一个游戏对象与另一个碰撞时，或者场景中某物爆炸时，可以使用脉冲使Cinemachine相机震动。",
    "paragraphTwo": "脉冲由两部分组成：",
    "paragraphThree": "1. 脉冲源：一个发射信号的组件，该信号从空间中的一个点发出并向外传播，类似于声波或冲击波。该发射由游戏中的事件触发。",
    "paragraphFour": "信号包括一个方向和一条曲线，指定信号强度随时间变化的函数。这些共同定义了沿指定轴线的震动，持续指定的时间。这种震动从起点向外传播，当到达脉冲监听器的位置时，该监听器可以对此作出反应。",
    "paragraphFive": "2. 脉冲监听器：一个Cinemachine扩展，允许Cinemachine相机“听到”脉冲，并通过震动作出反应。",
    "paragraphSix": "可以将其理解为单个“脉冲”。脉冲是脉冲源发射信号的单次发生。场景中的碰撞和事件触发脉冲，脉冲源生成脉冲，脉冲监听器对脉冲作出反应。",
    "subtitleOne": "开始使用脉冲",
    "paragraphSeven": "在场景中设置和使用脉冲，请执行以下操作：",
    "paragraphSevenList": [
      "将Cinemachine脉冲源或Cinemachine碰撞脉冲源组件添加到一个或多个您希望触发相机震动的游戏对象上。",
      "将Cinemachine脉冲监听器扩展添加到一个或多个Cinemachine相机上，使它们能够检测并对脉冲作出反应。"
    ]
  },
  "SplitScreenMultipleCameras": {
    "title": "分屏和多个Unity相机",
    "paragraphOne": "根据设计，Cinemachine相机并不会直接链接到Cinemachine大脑。相反，场景中的活动Cinemachine相机会由大脑动态发现，这样它们就可以通过预制件实例化或场景加载来存在。默认情况下，如果场景中存在多个Cinemachine大脑，它们都会找到相同的Cinemachine相机，并因此显示相同的内容。要将特定的Cinemachine相机分配给特定的大脑，使用Cinemachine频道。这与Unity层的工作方式相同。",
    "paragraphTwo": "首先，将您的Cinemachine相机设置为输出到所需的频道：",
    "paragraphThree": "接下来，将该频道添加到Cinemachine大脑的频道掩码中。掩码中可以同时存在多个频道。Cinemachine大脑将仅使用那些输出到掩码中存在的频道的Cinemachine相机。所有其他Cinemachine相机将被忽略。"
  },
  "UseInputSystem": {
    "title": "Cinemachine与输入系统兼容",
    "paragraphOne": "对于更复杂的输入配置，例如支持多个设备，您需要从输入系统包提供的PlayerInput组件接收输入。以下部分假设您已经知道如何设置此组件。有关更多信息，请参阅输入系统文档和示例。",
    "subtitleOne": "读取PlayerInput",
    "paragraphTwo": "要从设置为InvokeCSharpEvents的PlayerInput中读取值，您需要创建一个自定义InputAxisController，该控制器订阅onActionTriggered事件。下面的示例显示了如何接收并相应地连接这些输入。将此脚本添加到您的CinemachineCamera中，并分配PlayerInput字段。",
    "paragraphThree": "如果需要动态实例化相机，请参阅Cinemachine多相机文档和示例以获取更多信息。"
  },
  "KnownIssues": {
    "title": "已知问题",
    "subtitleOne": "累积缓冲投影矩阵",
    "paragraphOne": "如果累积的“抗锯齿”选项已启用，并且场景中包含Cinemachine相机切换，则在切换后相机的视场将不正确。",
    "paragraphTwo": "解决方法：在每一帧之后重置投影矩阵，在CinemachineBrain修改相机之后。"
  },

  "ComingSoom": {
    "title": "敬请期待",
    "paragraphOne": "当前页面还没有完成翻译和更新！如果您希望它尽快完成，请邮件提醒我们。",
    "paragraphTwo": "您也可以贡献自己的力量，帮助Unity中文开发者社区完成这个页面，并通过PR提交您的翻译。"
  },
  "Feedback": {
    "title": "对当前页面不满意？请给我们及时反馈！",
    "buttonOne": "尽快翻译当前页面",
    "buttonTwo": "该页面翻译有问题",
    "buttonThree": "该页面功能缺失",
    "sendFeedback": "提交"
  }
}
