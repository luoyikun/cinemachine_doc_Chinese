{
  "Common": {
    "InThisArticle": "IN THIS ARTICLE"
  },

  "CinemachinePackage": {
    "title": "Cinemachine package",
    "title.comment": "Cinemachine package's title",
    "descriptionParagraphOne": "Cinemachine is a suite of modules for controlling the Unity camera. Cinemachine solves the complex mathematics and logic of tracking targets, composing, blending, and cutting between shots. It is designed to significantly reduce the number of time-consuming manual manipulations and script revisions that take place during development.",
    "descriptionFirstParagraph.comment": "Cinemachine package's first paragraph description",
    "descriptionParagraphTwo": "The procedural nature of these modules makes Cinemachine robust and forgiving. When you make adjustments - for example, change an animation, vehicle speed, terrain, or other GameObjects in your Scene - Cinemachine dynamically adjusts its behavior to make the best shot. There is no need, for example, to re-write camera scripts just because a character turns left instead of right.",
    "descriptionSecondParagraph.comment": "Cinemachine package's second paragraph description",
    "descriptionParagraphThree": "Cinemachine works in real time across all genres including FPS, third person, 2D, side-scroller, top down, and RTS. It supports as many shots in your Scene as you need. Its modular system lets you compose sophisticated behaviors.",
    "descriptionThirdParagraph.comment": "Cinemachine package's third paragraph description",
    "descriptionParagraphFour": "Cinemachine works well with other Unity tools, acting as a powerful complement to Timeline, animation, and post-processing assets. Create your own extensions or integrate it with your custom camera scripts.",
    "descriptionFourthParagraph.comment": "Cinemachine package's fourth paragraph description"
  },

  "InstallationAndUpgrade": {
    "title": "Installation and upgrade",
    "title.comment": "Installation and upgrade section title",
    "installationParagraphOne": "Cinemachine is a free package, available for any project. You install Cinemachine like any other package.",
    "installationParagraph.comment": "Installation paragraph",
    "installationParagraphTwo": "After you install Cinemachine, a new GameObject > Cinemachine menu is available. You can also access this menu when you right-click inside the Hierarchy view.",
    "installationParagraphTwo.comment": "Installation paragraph two",
    "requirementsTitle": "Requirements",
    "requirementsTitle.comment": "Requirements title",
    "requirementsParagraphOne": "Cinemachine has few external dependencies. Just install it and start using it. If you are also using the Post Processing via HDRP or URP volumes, then adapter modules are provided - protected by ifdef directives which auto-define if the presence of the dependencies is detected.",
    "requirementsParagraphOne.comment": "Requirements paragraph one",
    "requirementsParagraphTwo": "There are similar ifdef-protected behaviours for other packages, such as Timeline and UGUI.",
    "requirementsParagraphTwo.comment": "Requirements paragraph two",
    "requirementsParagraphThree": "This version of Cinemachine is supported by the following versions of the Unity Editor:：",
    "requirementsParagraphThree.comment": "Requirements paragraph three",
    "requirementVersion": "2022.2.16f1 and later",
    "requirementVersion.comment": "Requirement version",
    "upgradingTitle": "Upgrading from previous versions of Cinemachine",
    "upgradingTitle.comment": "Upgrading title",
    "upgradingParagraphOne": "Cinemachine 3.0 is a major version change from CM 2.X, and the API and data format have changed significantly. Scripts written for the CM 2.X API are unlikely to run with 3.X without manual intervention. Also, the CM Camera instances in your project will themselves need upgrading.",
    "upgradingParagraphOne.comment": "Upgrading paragraph one",
    "upgradingParagraphTwo": "While it is possible to upgrade an existing project from CM 2.X, you should think carefully about whether you are willing to put in the work. It might be better in many cases just to stick with CM 2.X, which will continue to be supported for a while in parallel with CM 3.X. If you do choose to upgrade your project, please see the upgrade guide.",
    "upgradingParagraphTwo.comment": "Upgrading paragraph two",
    "upgradingParagraphThree": "Cinemachine 3.0 maintains support - in deprecated form - of obsolete CM2 classes that have been superceded by newer ones. This is to help ease the transition to the new API. However, it is strongly recommended that you upgrade your project to use the new API as soon as possible. The deprecated classes will be removed in a future release. To reduce code bloat in your deliverables, the deprecated class support can be removed immediately by defining CINEMACHINE_NO_CM2_SUPPORT in your project's Scripting Define Symbols.",
    "upgradingParagraphThree.comment": "Upgrading paragraph three",
    "upgradingFromOldTitle": "Upgrading from the old Asset Store version of Cinemachine",
    "upgradingFromOldTitle.comment": "Upgrading from old title",
    "upgradingFromOldParagraphOne": "If you already installed a very old version of Cinemachine from the Unity Asset Store, you should upgrade to the Cinemachine Package. It is recommended in this case to upgrade to Cinemachine 2.X, which in most cases is completely automatic.",
    "upgradingFromOldParagraphOne.comment": "Upgrading from old paragraph one",
    "upgradingFromOldParagraphTwo": "To upgrade to the Cinemachine Package:",
    "upgradingFromOldParagraphTwo.comment": "Upgrading from old paragraph two",
    "upgradingFromOldSteps": [
      "In Unity Editor, 2019.4+ or later, open your project.",
      "Save the current Scene you are working on.",
      "Create a new, empty Scene.",
      "In the Project window, delete the Cinemachine Asset and any CinemachinePostProcessing adaptor assets you may have installed.",
      "Install the Cinemachine 2.X package."
    ],
    "upgradingFromOldSteps.comment": "Upgrading from old Asset stores steps"
  },

  "UpgradingProjectFromCinemachine2X": {
    "UpgradingProjectFromCinemachine2XTitle": "Upgrading a Project from Cinemachine 2.X",
    "UpgradingProjectFromCinemachine2XParagraphOne": "Cinemachine 3.0 is a major version change from CM 2.X, and the API and data format have changed significantly. Scripts written for the CM 2.X API are unlikely to run with 3.X without manual intervention. Also, the CM objects in your project data will themselves need upgrading.",
    "UpgradingProjectFromCinemachine2XParagraphTwo": "While it is possible to upgrade an existing project from CM 2.X, you should think carefully about whether you are willing to put in the work. It might be better in many cases just to stick with CM 2.X, which will continue to be supported for a while in parallel with CM 3.X. If you do choose to consider upgrading your project, this guide will give you some pointers to make the process smoother.",

    "UpgradingYourProjectStepByStepTitle": "Upgrading your Project Step by Step",
    "UpgradingYourProjectStepByStepParagraphOne": "Here are the steps to take when upgrading an existing project from CM 2.X:",
    "UpgradingYourProjectStepByStepList": [
      "Back up your project. Don't skip this step.",
      "Use the Package Manager to upgrade your project to CM3. If you have custom scripts that use the Cinemachine API, they will likely break. Get them compiling again by doing the following:",
      "1 Update the using Cinemachine declarations. The namespaces have been changed to Unity.Cinemachine.",
      "2 Update any references to the renamed components.",
      "3 Update the broken CM field names. For the most part, this just means removing the m_ prefix. In other cases, there might be a bit more to do, but the appropriate action to take should be clear by looking at the code in each case.",
      "4 At this point your project should more-or-less run as before, using the obsolete classes.",
      "The new CinemachineCamera class that replaces CinemachineVirtualCamera and CinemachineFreeLook inherits from CinemachineVirtualCameraBase. Where possible, replace your script references to use this base class rather than the derived type. If you do this, the CM upgrader tool will be able to preserve existing object references, since the old and new classes all inherit from this same base class.",
      "Upgrade the project data by running the Cinemachine Upgrader. You can launch the Cinemachine Upgrader tool from any CM VirtualCamera or FreeLook inspector.",
      "Because CM component types have changed, you will have to manually go through your scripts and update any specific references to be to the new type. The console log is your friend: \"obsolete\" warnings will point you to the places that need attention.",
      "After the data upgrade, object references might be broken. You will need to check and repair them if necessary.",
      "If you are using layers to filter cameras into separate split-screen brains, that filtering will stop working until after you have upgraded to CinemachineCameras and switched the filtering over to Channels."
    ],
    "UpgradingYourProjectStepByStepParagraphTwo": "Note: if at any stage you get errors of this nature, just restart Unity:",
    "WhatHasChangedInTheAPITitle": "What has Changed in the API",
    "WhatHasChangedInTheAPIParagraphOne": "Some components were replaced by new components, others were renamed. Field names have changed. Namespaces have changed. For most of these issues, you will see errors or deprecation warnings in the console, which will point you to the areas in your code that need attention.",
    "WhatHasChangedInTheAPIParagraphTwo": "One thing to note: the new CinemachineCamera class that replaces CinemachineVirtualCamera and CinemachineFreeLook inherits from CinemachineVirtualCameraBase. If you can replace your script references to use this base class wherever possible, then existing object references will be preserved when the data is upgraded, since the old classes are also inherited from this same base class.",
    "NewNamespacesTitle": "New Namespaces",
    "NewNamespacesParagraphOne": "Namespaces have changed to be more consistent with Unity standards.",
    "NewNamespacesList": [
      "Cinemachine is now Unity.Cinemachine",
      "Cinemachine.Editor is now Unity.Cinemachine.Editor",
      "Cinemachine.Utility has been folded into Unity.Cinemachine."
    ],
    "NewComponentsWithClearerNamesTitle": "New Components with Clearer Names",
    "NewComponentsWithClearerNamesParagraphOne": "Old components have been replaced by new components. These are not renames, they are new component types. The old components still exist but are deprecated. If your scripts refer to any of them, they will need to be updated once the data upgrade has been done.",
    "NewComponentsWithClearerNamesList": [
      "CinemachineVirtualCamera is replaced by CinemachineCamera.",
      "CinemachineFreeLook is replaced by CinemachineCamera.",
      "CinemachinePath and CinemachineSmoothPath are replaced by Spline Container, provided by Unity's new native spline implementation.",
      "CinemachineDollyCart is replaced by CinemachineSplineCart.",
      "CinemachineTransposer is replaced by CinemachineFollow.",
      "CinemachineOrbitalTransposer is replaced by CinemachineOrbitalFollow",
      "CinemachineFramingTransposer is replaced by CinemachinePositionComposer.",
      "CinemachineComposer is replaced by CinemachineRotationComposer.",
      "CinemachinePOV is replaced by CinemachinePanTilt.",
      "CinemachineTrackedDolly is replaced by CinemachineSplineDolly.",
      "CinemachineGroupComposer is replaced by the CinemachineGroupFraming extension used in conjunction with CinemachineRotationComposer.",
      "CinemachineCollider is replaced by CinemachineDeoccluder",
      "CinemachineConfiner is replaced by CinemachineConfiner2D and CinemachineConfiner3D",
      "Cinemachine3rdPersonFollow is replaced by CinemachineThirdPersonFollow.",
      "CinemachineSameAsFollowTarget is replaced by CinemachineRotateWithFollowTarget."
    ],
    "RenamedComponentsTitle": "Renamed Components",
    "RenamedComponentsList": [
      "Cinemachine3rdPersonAim has been renamed to CinemachineThirdPersonAim.",
      "CinemachineBlendListCamera has been renamed to Cinemachine Sequencer Camera."
    ],
    "RenamedFieldsTitle": "Renamed Fields",
    "RenamedFieldsParagraphOne": "The old convention of using \"m_FieldName\" has been changed to follow Unity's latest naming conventions. Consequently, all of the \"m_\" prefixes have been removed from field names, everywhere. If your scripts don't compile because of this, the first remedy is to remove the \"m_\" from the field name that your script is referencing. Most of the time, that will be enough. Occasionally, some field names were changed more significantly. It should be fairly easy to find the appropriate replacements.",
    "RenamedFieldsParagraphTwo": "The SimpleFollowWithWorldUp binding mode has been renamed to LazyFollow.",
    "CleanerObjectStructureNoHiddenGameObjectsTitle": "Cleaner Object Structure, No Hidden GameObjects",
    "CleanerObjectStructureNoHiddenGameObjectsParagraphOne": "Cinemachine 2.x implemented the CM pipeline on a hidden GameObject child of the vcam, named \"cm\". This has been removed in CM 3.0, and CM pipeline components (such as OrbitalFollow or RotationComposer) are now implemented directly as components on the CinemachineCamera GameObject. You can access them as you would any other components: GetCinemcachineComponent() is no longer necessary, just use GetComponent().",
    "CleanerObjectStructureNoHiddenGameObjectsParagraphTwo": "You will now see the cm child objects of your legacy CM vcams in the hierarchy, because CM3 unhides them. This is not a license to mess with these objects - they were hidden for a reason. We recommend that you get rid of them by upgrading the parent objects to their CM3 equivalents.",

    "NewInputHandlingTitle": "New Input Handling",
    "NewInputHandlingParagraphOne": "User input has been decoupled from the Cinemachine Components: they no longer directly read user input, but expect to be driven by an external component. CinemachineInputAxisController is provided to do this job, but you could also choose to implement your own input controller by inheriting InputAxisControllerBase.",

    "NewEventsArchitectureTitle": "New Events Architecture",
    "NewEventsArchitectureParagraphOne": "While CM2.X has events in CinemachineVirtualCamera and CinemachineBrain, CM3 only fires global events via CinemachineCore. Scripts can add listeners to those events and take action based on them. Listeners will receive events for all cameras and all Brains.",
    "NewEventsArchitectureParagraphTwo": "Camera-specific and Brain-specific events are now supported via two new behaviours: Cinemachine Brain Events and Cinemachine Camera Events. These monitor the global events and fire more specialized ones related to the objects to which they are attached.",

    "NewSplineImplementationTitle": "New Spline Implementation",
    "NewSplineImplementationParagraphOne": "Cinemachine's paths are now implemented using Unity's native Splines, which provide equivalent functionality. The Cinemachine Upgrader will automatically convert your CM paths to Splines. The CM path implementations still exist, but are now deprecated.",

    "DecoupledFromUnityLayersTitle": "Decoupled from Unity Layers",
    "DecoupledFromUnityLayersParagraphOne": "In CM2, CinemachineBrain would only process CinemachineCameras that were assigned to layers included in the associated Camera's culling mask. This mechanism was useful in situations such as split-screen, to cause specific CinemachineCameras to be assigned to specific Brains. In CM3, this has been replaced by Cinemachine Channels. These are dedicated layers that only Cinemachine uses, so that Unity layers don't get needlessly squandered. CinemachineCameras are assigned to a Cinemachine Channel, and the CinemachineBrain has a channel mask. Normally, the \"Default\" channel is used, and only needs to be changed in specific situations where channel separation is a requirement.",

    "LensModeOverrideTitle": "Lens Mode Override",
    "LensModeOverrideParagraphOne": "If your project is using virtual cameras with a Lens Mode Override (e.g. changing between physical and perspective and ortho cameras), then this will stop working until you enable mode override and assign a default lens mode in the CinemachineBrain.",

    "UpgradingTheProjectDataTitle": "Upgrading the Project Data",
    "UpgradingTheProjectDataParagraphOne": "Once the scripts are using the new API, you can upgrade the project data to convert legacy CM objects to their CM3 counterparts. Cinemachine comes with a data upgrade tool to facilitate this. It's not a trivial operation, because in addition to the vcam objects in your scene, it's also necessary to upgrade prefabs and animation assets that might be referencing them.",
    "UpgradingTheProjectDataParagraphTwo": "You can launch the Cinemachine Upgrader upgrade tool from any CM VirtualCamera or FreeLook inspector:",

    "UpgradingASingleObjectTitle": "Upgrading a Single Object",
    "UpgradingASingleObjectParagraphOne": "If you want to upgrade only the Cinemachine object currently being inspected, you can do this provided that it isn't a prefab instance. In this case, it will upgrade only the inspected objects, replacing them with CM3 equivalents. Undo is supported, so you can try it out and then change your mind if you want.",
    "UpgradingASingleObjectParagraphTwo": "Note that any script references to this object will be lost (because the class will change), as will any animation tracks that are writing to fields inside this camera (because classes and field names have changed). Timelines referencing this object will lose their bindings. If you have script references or animation tracks or if this camera is part of a prefab or prefab instance, then you need to use the \"Upgrade Entire Project\" option, which will scan the project for references and make the appropriate updates.",

    "UpgradingASingleSceneTitle": "Upgrading a Single Scene",
    "UpgradingASingleSceneParagraphOne": "You can also choose to update all the CM objects in the current scene. Again, this will not update any assets outside of the scene, so it is not appropriate for any but the simplest of scenes. Undo is also supported for this operation.",

    "UpgradingTheWholeProjectTitle": "Upgrading the Whole Project",
    "UpgradingTheWholeProjectParagraphOne": "The \"Upgrade Entire Project\" option will upgrade all the objects in all the scenes and all the prefabs. There is logic to handle animation tracks, script references, and prefab instances. It's a major operation and every scene and prefab in the project will be opened and saved multiple times. Undo is not supported, so be sure to make a complete backup first."
  },
  "GetStarted": {
    "title": "Get started with Cinemachine",
    "paragraphOne": "Get the essential information to understand how Cinemachine works and follow instructions to set up the minimum functional layers to start using Cinemachine in your project.",
    "sections:": [
      "Cinemachine core concepts",
      "Set up a basic Cinemachine environment",
      "Set up multiple Cinemachine Cameras and transitions",
      "Add procedural behavior to a Cinemachine Camera",
      "Set up Timeline with Cinemachine Cameras",
      "Use convenient tools and shortcuts"
    ],
    "descriptions": [
      "Learn about the Cinemachine base elements and core functionality.",
      "Set up your Unity project with the minimum required elements to make a functional Cinemachine environment.",
      "Set up a Cinemachine environment with multiple Cinemachine Cameras and manage the transitions between them.",
      "Add procedural behavior to a Cinemachine Camera to make it follow a target, shake, and more.",
      "Set up Timeline in a Cinemachine environment to choreograph Cinemachine Cameras and produce a predictable shot sequence.",
      "Use interface tools and shortcuts and target the proper Cinemachine elements to set up according to your needs and ease your configuration experience."
    ]
  },
  "DiscoverConcepts": {
    "title": "Discover Cinemachine concepts",
    "paragraphOne": "Learn about the Cinemachine base elements and core functionality.",
    "sections": [
      "Cinemachine essential elements",
      "Camera control and transitions",
      "Procedural motion",
      "Cinemachine and Timeline"
    ],
    "descriptions": [
      "What are the essential elements that to make a functional Cinemachine environment: Unity Camera, Cinemachine Brain, and Cinemachine Cameras.",
      "What are the conditions and mechanisms that make Cinemachine Cameras take turns controlling the Unity Camera and transition between each other by blend or cut.",
      "How procedural behaviors and extensions can make a Cinemachine Camera dynamically move, shake, track targets, compose its own shots, respond to user inputs, move along a predefined path, react to external impulse signals, produce post-processing effects, and more.",
      "How Cinemachine Cameras work with Timeline when you need to produce a predictable shot sequence with choreographed cameras."
    ]
  },
  "EssentialElements": {
    "title": "Cinemachine essential elements",
    "paragraphOne": "Learn about the essential elements that make a functional Cinemachine environment.",
    "subtitleOne": "Overview",
    "paragraphTwo": "A functional Cinemachine setup involves three main types of elements:",
    "listOne": [
      "A single Unity Camera which captures the images across the Scene,",
      "A Cinemachine Brain which enables the Cinemachine functionality in the Unity Camera, and",
      "One or multiple Cinemachine Cameras which take turns controlling the Unity Camera according to their status."
    ],
    "paragraphThree": "Cinemachine setup example: the Unity Camera with its Cinemachine Brain component and three Cinemachine Cameras.",
    "subtitleTwo": "Unity Camera",
    "paragraphFour": "The Unity Camera is a GameObject that includes a Camera component, as opposed to Cinemachine Cameras, which includes other types of components to control the Unity Camera.",
    "paragraphFive": "A Cinemachine setup must include only one Unity Camera, which is then the only GameObject that captures the images from your Scene while the Cinemachine Cameras control it.",
    "subtitleThree": "Cinemachine Brain",
    "paragraphSix": "To work with Cinemachine, the Unity Camera GameObject must include a Cinemachine Brain component. This component is mainly responsible to:",
    "listTwo": [
      "Monitor all active Cinemachine Cameras in the Scene.",
      "Determine which Cinemachine Camera controls the Unity Camera.",
      "Handle the transition when another Cinemachine Camera takes control of the Unity Camera."
    ],
    "noteOne": "When you use Timeline to get a choreographed sequence of Cinemachine Camera shots, Timeline overrides the Cinemachine Brain for Cinemachine Camera priority and transition management.",
    "subtitleFour": "Cinemachine Cameras",
    "paragraphSeven": "The Cinemachine Cameras (formerly named Virtual Cameras) are GameObjects that act as camera placeholders ready to take control of the Unity Camera according to their status.",
    "paragraphEight": "When a Cinemachine Cameras takes control of the Unity Camera, it dynamically overrides its properties and behavior, which affects:",
    "listThree": [
      "Where the Unity Camera is positioned in the Scene.",
      "What the Unity Camera aims at.",
      "How the Unity Camera behaves through time."
    ],
    "subtitleFive": "Cinemachine Camera GameObjects",
    "paragraphNine": "Cinemachine Camera GameObjects are separate from the Unity Camera GameObject.",
    "listFour": [
      "They behave independently, and must not be nested within each other.",
      "They don't include a Camera component, as opposed to the Unity Camera GameObject.",
      "They must include a Cinemachine Camera component.",
      "They can include additional Cinemachine components to manage procedural motion and add extended functionality."
    ],
    "paragraphTen": "Hierarchy example: a Scene containing a Unity Camera with Cinemachine Brain and multiple Cinemachine Cameras.",
    "subtitleSix": "Single or multiple Cinemachine Cameras",
    "paragraphEleven": "You can create as many Cinemachine Cameras as required for your project, but you can also get a fully functional setup with a single Cinemachine Camera, depending on your needs. For example:",
    "listFive": [
      "If you want the Unity Camera to follow a single character, you can use a single Cinemachine Camera and set it up with a follow behavior that corresponds to your needs. In the end, this Cinemachine Camera will be the only one to control the Unity Camera.",
      "If your project requires multiple shots over multiple places, you should create one Cinemachine Camera per shot, with or without specific procedural behavior. In that case, you have to understand how Unity handles Cinemachine Camera activations and transitions."
    ],
    "subtitleSeven": "Processing power consumption",
    "paragraphTwelve": "Cinemachine encourages you to create many Cinemachine Cameras. The Cinemachine Camera is designed to consume little processing power. If your Scene is performance-sensitive, deactivate all but the essential Cinemachine Cameras at any given moment for best performance.",
    "subtitleEight": "Additional resources",
    "paragraphThirteen": "Set up a basic Cinemachine environment"
  },
  "TrackingScenario3D": {
    "title": "3D tracking scenarios",
    "paragraphOne": "Use Cinemachine to follow and look at the active characters of your 3D games.",
    "list:": [
      "Follow and frame a character",
      "Follow and frame a group",
      "Create a FreeLook Camera",
      "Create a Third Person Camera"
    ]
  },
  "TopDownGamesAnd2DPage": {
    "title": "2D and top-down games",
    "paragraphOne": "Use and configure Cinemachine to meet your expectations according to specific requirements of 2D graphics and top-down games.",
    "list": ["Cinemachine and 2D graphics", "Cinemachine and top-down games"]
  },
  "ConstrainCameraToPath": {
    "title": "Constrain a camera to a path",
    "paragraphOne": "Use a Spline to constrain the movement of a camera along a predefined and customizable path.",
    "paragraphTwo": "A Spline path is a path formed by a Spline in a scene. Use a Spline to specify a fixed course to position or animate a CinemachineCamera. Use the Spline Dolly behaviour to make your CinemachineCamera follow a Spline path.",
    "paragraphThree": "To create a Cinemachine Camera with a dolly path:",
    "pargraphThreeList": [
      "In the Unity menu, choose GameObject > Cinemachine > Dolly Camera with Spline. A new Cinemachine Camera and spline appear in the Hierarchy.",
      "In the Hierarchy window, select the new dolly spline GameObject.",
      "In the Inspector or in the Scene View, add and adjust waypoints."
    ],
    "paragraphFour": "Any Unity spline can be used as a path in Cinemachine. Just drag it into the Spline Dolly Spline property field, and immediately the CinemachineCamera will be confined to the spline.",
    "paragraphFive": "By default, Unity Splines contain no rotation data. Camera rotation will be inferred from the spline tangent at any point, combined with the world Up vector. To add rotation about the tangent, you can use the Cinemachine Spline Roll behaviour. This allows you to specify Roll values for any point along the spline. Roll values are used to rotate the camera about the spline tangent at that point, giving you more control over the camera's final rotation.",
    "paragraphSix": "If a Cinemachine Spline Roll behaviour is added to the spline, all cameras and dolly carts that use the spline will see it. Alternatively, you can add the Cinemachine Spline Roll behaviour to the Cinemachine Camera itself, in which case the roll will only apply to it.    "
  },
  "ApplyNoiseSimulationPage": {
    "title": "Apply noise to simulate camera shake",
    "paragraphOne": "To apply a noise behavior to a Cinemachine Camera:",
    "paragraphOneList": [
      "In the Hierarchy, select your Cinemachine Camera.",
      "In the Inspector, in the Cinemachine Camera component, select Noise and then select Basic Multi Channel Perlin. This adds a noise behavior to the Cinemachine Camera.",
      "In the Basic Multi Channel Perlin component, under Noise Profile, choose an existing noise profile asset or create your own profile.",
      "Use Amplitude Gain and Frequency Gain to fine-tune the noise."
    ],
    "paragraphTwo": "Noise is meant to be used for things such as hand-held camera effects, where the noise is continuous. For sudden shakes (e.g. in response to events like explosions), we recommend the use of Impulse Impulse rather than Noise."
  },
  "ManageGroupedCameras": {
    "title": "Manage grouped cameras",
    "paragraphOne": "A Manager Camera oversees many CinemachineCameras but acts as a single CinemachineCamera from the point of view of Cinemachine Brain and Timeline.",
    "paragraphTwo": "Cinemachine includes these manager cameras:",
    "paragraphTwoList": [
      "Sequencer Camera: Executes a sequence of blends or cuts of its child CinemachineCameras.",
      "Clear Shot Camera: Picks the child CinemachineCamera with the best view of the target.",
      "State-Driven Camera: Picks a child CinemachineCamera in reaction to changes in animation state.",
      "Mixing Camera: Creates a continuous blend by using the weighted average of up to eight child CinemachineCameras."
    ],
    "paragraphThree": "Because manager cameras act like normal CinemachineCameras, you can nest them. In other words, create arbitrarily complex camera rigs that combine regular CinemachineCameras and manager cameras.",
    "subtitleOne": "Making Your Own Custom Manager Camera",
    "paragraphFour": "It is also possible to make your own manager camera that selects its current active child according to an arbitrary algorithm that you provide. For instance, if you are making a 2D Platformer and want a camera rig that frames itself differently according to whether the character is moving right or left, or jumping, or falling, a custom CameraManager class might be a good approach.",
    "paragraphFive": "To do this, make a new class that inherits CinemachineCameraManagerBase. This base class implements an array of CinemachineCamera children, and a blender.",
    "paragraphSix": "Next, implement the abstract ChooseCurrentCamera method. This is called every frame while the manager is active, and should return the child camera that ought to be active this frame. Your custom class can make that decision any way it likes. In the example, it would look at the player state to find out the facing direction and the jumping/falling state, and choose the appropriate child camera.",
    "paragraphSeven": "If the new desired camera is different from what it was on the last frame, CinemachineCameraManagerBase will initiate a blend, according to what you set up in its DefaultBlend and CustomBlends fields.",
    "paragraphEight": "Once you've added the child cameras with the settings you like for each player state and have wired them into your manager instance, you will have a Cinemachine rig that adjusts itself according to player state. The rig itself will look to the rest of the system just like an ordinary CinemachineCamera, and so can be used wherever CinemachineCameras can - including being nested within other rigs.",
    "paragraphNine": "Note that Cinemachine ships with State-Driven Camera, which implements this functionality provided that the relevant player state is encoded in an Animation Controller State-Machine. You would implement your own manager in the case that the state is not being read from an Animation Controller.",
    "subtitleTwo": "Managed Cameras need to be GameObject children of the manager",
    "paragraphTen": "This is mainly to prevent problems that can occur if you nest managers and end up with a recursive loop. Forcing the managed cameras to be children makes recursion impossible."
  },
  "AvoidCollisionsAndEvaluateShots": {
    "title": "Avoid collisions and evaluate shots",
    "paragraphOne": "As characters and objects move around in a complex Scene, obstacles in the Scene sometimes come between a camera and its target. Similarly, you might need to move a camera to a position in the Scene that another GameObject already occupies. Cinemachine provides extensions to handle these situations:",
    "paragraphOneList": [
      "Cinemachine Decollider",
      "Cinemachine Deoccluder",
      "Cinemachine Confiner 3D",
      "Cinemachine Confiner 2D"
    ]
  },
  "CinemachineEvents": {
    "title": "Cinemachine Events",
    "paragraphOne": "Cinemachine will generate events whenever cameras are activated and deactivated, and also when blends are started and when they finish. Furthermore, an event is generted when there is a camera cut - that is, when the active cinemachine camera changes without blending.",
    "paragraphTwo": "When Cinemachine sends an event, it is sent globally via CinemachineCore. Scripts can add listeners to those events and take action based on them. Listeners will receive events for all cameras.",
    "paragraphThree": "Events are generated in every context that manages blends. This includes the CinemachineBrain, which handles blends at the highest level, but it also applies to Cinemachine Manager Cameras, which thenselves manage blends between their child cameras.",
    "paragraphFour": "Sometimes it's desirable to have events sent only for a specific camera, so that scripts can be notified based on this specific camera's activity without having to provide code to filter the events. Cinemachine provides the following behaviours to execute this filtering logic.",
    "paragraphFourList": [
      "You can trap events that relate to activating or deactivating a specific CinemachineCamera or ManagerCamera by adding a Cinemachine Camera Events behaviour to it.",
      "You can trap events generated by a ManagerCamera by adding a Cinemachine Camera Manager Events behaviour to it.",
      "You can trap events that are generated by a specific CinemachineBrain by adding a Cinemachine Brain Events to it."
    ]
  },
  "CinemachineImpulse": {
    "title": "Cinemachine Impulse",
    "paragraphOne": "Cinemachine Impulse generates and manages camera shake in response to game events. For example, you can use Impulse to make a CinemachineCamera shake when one GameObject collides with another, or when something in your Scene explodes.",
    "paragraphTwo": "Impulse has two parts:",
    "paragraphThree": "1. Impulse Source: a component that emits a signal that originates at a point in space and propagates outwards, much like a sound wave or a shock wave. This emission is triggered by events in the game.",
    "paragraphFour": "The signal consists of a direction, and a curve specifying the strength of the signal as a function of time. Together, these effectively define a shake along a specified axis, lasting a specified amount of time. This shake travels outward from the point of origin, and when it reaches the location of an Impulse Listener, that listener can respond to it.",
    "paragraphFive": "2. Impulse Listener: a Cinemachine extension that allows a CinemachineCamera to “hear” an impulse, and react to it by shaking.",
    "paragraphSix": "It’s useful to think about this in terms of individual “impulses.” An impulse is a single occurrence of an Impulse Source emitting a signal. Collisions and events in your Scenes trigger impulses, Impulse Sources generate impulses, and Impulse Listeners react to impulses.",
    "subtitleOne": "Getting started with Impulse",
    "paragraphSeven": "To set up and use Impulse in a Scene, do the following:",
    "paragraphSevenList": [
      "Add Cinemachine Impulse Source or Cinemachine Collision Impulse Source components to one or more GameObjects that you want to trigger a camera shake.",
      "Add a Cinemachine Impulse Listener extension to one or more Cinemachine CinemachineCameras so they can detect and react to impulses."
    ]
  },
  "SplitScreenMultipleCameras": {
    "title": "Split screen and multiple Unity Cameras",
    "paragraphOne": "By design, CinemachineCameras are not directly linked to CinemachineBrains. Instead, active CinemachineCameras in the scene are dynamically found by the Brain, allowing them to be brought into existence via prefab instantiation or scene loading. By default, if multiple CinemachineBrains exist in the scene, they will all find the same CinemachineCameras and consequently display the same thing. To assign a specific CinemachineCamera to a specific Brain, Cinemachine Channels are used. This works the same way as Unity Layers.",
    "paragraphTwo": "First, set your CinemachineCamera to output to the desired channel:",
    "paragraphThree": "Next, add that channel to the CinemachineBrain's Channel mask. Multiple channels may be present simultaneously in the mask. The CinemachineBrain will use only those CinemachineCameras that output to channels that are present in the mask. All other CinemachineCameras will be ignored."
  },
  "UseInputSystem": {
    "title": "Use Input System with Cinemachine",
    "paragraphOne": "For more complex input configurations like supporting multiple devices, you will need to receive inputs from the PlayerInput component provided by the Input System package. The following section assumes you already know how to setup this component. For more information, see the Input System documentation and samples.",
    "subtitleOne": "Read from PlayerInput",
    "paragraphTwo": "To read values from a PlayerInput with a behaviour set to InvokeCSharpEvents, you need to create a custom InputAxisController that subscribes to onActionTriggered. The example below shows how to receive and wire those inputs accordingly. Add this script to your CinemachineCamera and assign the PlayerInput field.",
    "paragraphThree": "For more information, see the Cinemachine Multiple Camera documentation and example if you need to dynamically instantiate cameras."
  },
  "KnownIssues": {
    "title": "Known Issues",
    "subtitleOne": "Accumulation Buffer Projection Matrix",
    "paragraphOne": "If accumulation's 'Anti-aliasing' option is enabled and the scene contains a Cinemachine camera cut, the camera's FOV will be incorrect after the cut.",
    "subtitleTwo": "Workaround: Reset the projection matrix every frame, after CinemachineBrain has modified the camera."
  },

  "ComingSoom": {
    "title": "Coming soon!",
    "paragraphOne": "The current page is not yet fully translated and updated! If you would like it to be completed as soon as possible, please email us.",
    "paragraphTwo": "You can also contribute to the Unity Chinese Developer Community to complete this page and submit your translation via PR."
  },

  "Feedback": {
    "title": "Not satisfied with the page? Let us know!",
    "buttonOne": "We need Chinese",
    "buttonTwo": "Translation is inaccurate",
    "buttonThree": "Page is Functionaly broken",
    "sendFeedback": "Submit"
  }
}
